#!/usr/bin/perl

# Copyright (c) 2017 Todd T. Fries <todd@fries.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use Data::Dumper;
use Getopt::Std;
use JSON;
use LWP::UserAgent;

use WWW::Hetzner;

STDERR->autoflush(1);
STDOUT->autoflush(1);

my $json = JSON->new->allow_nonref;


our $opt_v = 0;
our $opt_c = $ENV{'HOME'}."/.hcli.conf";

# filter options
our $opt_C = 5682;
our $opt_D = 4096;
our $opt_M = 48;

getopts('c:vC:D:M:');

my $conf = $opt_c;
our $huser;
our $hpass;

my $hetzner = WWW::Hetzner->new($conf);

my $URL = "https://robot-ws.your-server.de/order/server_market/product?search=Ent";

if (defined($opt_C)) {
	$URL .= "&min_cpu_benchmark=${opt_C}"
}
if (defined($opt_M)) {
	$URL .= "&min_memory_size=${opt_M}"
}

my $text = $hetzner->req($URL);

print "OUTPUT:\n";


my $parsed = parse_json(${$text}, "robot-ws");
#print recurse_dump($parsed);
#print "\n\n";

printf "%8s %7s %5s %5s %5s %3s %6s %6s %3s %6s\n",
	"DC","prodid","sys","bench","disk","MEM","EUR","next","TB","CPU info";
foreach my $server ( @{$parsed} ) {

	my $dc   = $server->{product}->{datacenter};
	my $mem  = $server->{product}->{memory_size};
	my $cpub = $server->{product}->{cpu_benchmark};
	my $disk = $server->{product}->{hdd_count} * $server->{product}->{hdd_size};

	if ($cpub < $opt_C) {
		next;
	}
	if ($mem < $opt_M) {
		next;
	}
	if ($disk < $opt_D) {
		next;
	}
	my $traffic = $server->{product}->{traffic};
	$traffic =~ s/ TB$//;
	$dc =~ s/-DC/-/;

	printf "%8s %7d %5s %5d %5d %3d %6.2f %6d %3s %s\n",
		$dc,
		$server->{product}->{id},
		$server->{product}->{name},
		$cpub,
		$disk,
		$server->{product}->{memory_size},
		$server->{product}->{price},
		$server->{product}->{next_reduce},
		$traffic,
		$server->{product}->{cpu},
}

sub parse_json {
	my ($str,$name) = @_;

	my $parsed;
	eval {
		$parsed = $json->decode( $str );
	};
	if ($@) {
		die("%s: json->decode('%s') Error %s\n", $name, $str, $@);
		return undef;
	}
	if ($opt_v > 0) {
		printf "Pretty %s: %s\n", $name, $json->pretty->encode( $parsed )."\n";;
	}
	return $parsed;
}


sub recurse_dump {
        my ($item) = @_;
        my $d = Data::Dumper->new([$item]);
        $d->Purity(1);
        $d->Terse(0);
        $d->Deepcopy(1);
        $d->Indent(2);
        $d->Sortkeys(1);
        #$d->Deparse(1);
	return $d->Dump();
}
