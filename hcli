#!/usr/bin/perl

# Copyright (c) 2017 Todd T. Fries <todd@fries.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use Data::Dumper;
use Getopt::Std;
use JSON;
use LWP::UserAgent;
use URI::Escape qw( uri_escape_utf8 );

use WWW::Hetzner;
use WWW::Hetzner::Server;

STDERR->autoflush(1);
STDOUT->autoflush(1);

my $json = JSON->new->allow_nonref;

our $opt_v = 0;
our $opt_c = $ENV{'HOME'}."/.hcli.conf";
our $opt_p;

getopts('c:p:v');

my $conf = $opt_c;

my $hetzner = WWW::Hetzner->new($conf);

if ($opt_p eq "ip") {

my $call = "ip";
my $parsed = $hetzner->req($call);
print recurse_dump($parsed);

} elsif($opt_p eq "servers") {
my $call = "server";
my $parsed = $hetzner->req($call);
foreach my $s (@{$parsed}) {
	my $ip = $s->{server}->{server_ip};
	#printf "server ip: %s\n", $ip;
	my $srvr = WWW::Hetzner::Server->new($hetzner, $ip);
	my @sub = @{$srvr->get('subnet')};
	printf "%d %12s: %s\n",
		$srvr->get('server_number'),
		$srvr->get('server_name'),
		$srvr->get('paid_until'),
	;
	my $server_ip = $srvr->get('server_ip');
	my $server_gw = $srvr->get('ip')->get('gateway');
	if (!defined($server_gw)) {
		$server_gw = "<undef>";
	}
	printf "\t%15s gw %15s\n",
		$server_ip,
		$server_gw,
	;
	printf "\t%s/%s\n",
		$sub[0]->{ip},
		$sub[0]->{mask},
	;
	my ($i,$o,$s) = $srvr->traffic;
	if (defined($i) && defined($o) && defined($s)) {
		printf "\ttraffic in/out/sum = %f/%f/%f\n", $i, $o, $s;
	}
	my $ptr = $srvr->rdns;
	if (defined($ptr)) {
		printf "\trdns %s ptr %s\n", $server_ip, $ptr;
	}
	my $cancel = $srvr->cancel;
	if (defined($cancel)) {
		printf "\tcancel earliest %s, status %s, date %s, reason %s\n",
			$cancel->get('earliest_cancellation_date'),
			$cancel->get('cancelled'),
			$cancel->get('cancellation_date'),
			$cancel->get('cancellation_reason'),
		;
	}
	#my $fire = $srvr->firewall;
	#print recurse_dump($fire);
}
#print recurse_dump($parsed);

} elsif($opt_p eq "subnet") {
my $call = "subnet";
my $parsed = $hetzner->req($call);
print recurse_dump($parsed);

} elsif($opt_p eq "rdns") {
my $call = "rdns";
my $parsed = $hetzner->req($call);
print recurse_dump($parsed);

} elsif($opt_p eq "sshkey") {
my $call = "key";
my $parsed = $hetzner->req($call);
print recurse_dump($parsed);

} elsif($opt_p eq "products") {
my $call = "order/server/product";
my $parsed = $hetzner->req($call);
print recurse_dump($parsed);

} elsif($opt_p eq "storagebox") {
my $call = "storagebox";
my $parsed = $hetzner->req($call);
print recurse_dump($parsed);

} elsif($opt_p eq "server_transactions") {
my $call = "order/server/transaction";
my $parsed = $hetzner->req($call);
print recurse_dump($parsed);

} elsif($opt_p eq "market_transactions") {
my $call = "order/server_market/transaction";
my $parsed = $hetzner->req($call);
print recurse_dump($parsed);

} elsif($opt_p eq "traffic") {
my $call = "traffic";
my $type="month";
my $from=uri_escape_utf8("2017-01-01");
my $to=uri_escape_utf8("2017-12-31");
$call .= "?type=$type";
$call .= "&from=$from";
$call .= "&to=$to";
my $parsed = $hetzner->req($call);
print recurse_dump($parsed);

} elsif($opt_p eq "market_search") {

# filter options
our $opt_C = 5682;
our $opt_D = 4096;
our $opt_M = 48;

getopts('C:D:M:');

my $call = "order/server_market/product?search=Ent";

if (defined($opt_C)) {
	$call .= "&min_cpu_benchmark=${opt_C}"
}
if (defined($opt_M)) {
	$call .= "&min_memory_size=${opt_M}"
}

print "OUTPUT:\n";


my $parsed = $hetzner->req($call);
#print recurse_dump($parsed);
#print "\n\n";

printf "%8s %7s %5s %5s %5s %3s %6s %6s %3s %6s\n",
	"DC","prodid","sys","bench","disk","MEM","EUR","next","TB","CPU info";
foreach my $server ( @{$parsed} ) {

	my $dc   = $server->{product}->{datacenter};
	my $mem  = $server->{product}->{memory_size};
	my $cpub = $server->{product}->{cpu_benchmark};
	my $disk = $server->{product}->{hdd_count} * $server->{product}->{hdd_size};

	if ($cpub < $opt_C) {
		next;
	}
	if ($mem < $opt_M) {
		next;
	}
	if ($disk < $opt_D) {
		next;
	}
	my $traffic = $server->{product}->{traffic};
	$traffic =~ s/ TB$//;
	$dc =~ s/-DC/-/;

	printf "%8s %7d %5s %5d %5d %3d %6.2f %6d %3s %s\n",
		$dc,
		$server->{product}->{id},
		$server->{product}->{name},
		$cpub,
		$disk,
		$server->{product}->{memory_size},
		$server->{product}->{price},
		$server->{product}->{next_reduce},
		$traffic,
		$server->{product}->{cpu},
}
} else {
	my $p = $opt_p;
	if (!defined($p)) {
		$p = "<undef>";
	}
	printf "personality '%s' not found\n", $p;
	exit(1);
}

sub recurse_dump {
        my ($item) = @_;
        my $d = Data::Dumper->new([$item]);
        $d->Purity(1);
        $d->Terse(0);
        $d->Deepcopy(1);
        $d->Indent(2);
        $d->Sortkeys(1);
        #$d->Deparse(1);
	return $d->Dump();
}
