#!/usr/bin/perl

# Copyright (c) 2017 Todd T. Fries <todd@fries.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use Data::Dumper;
use Getopt::Std;
use URI::Escape qw( uri_escape_utf8 );

use WWW::Hetzner;
use WWW::Hetzner::Server;

STDERR->autoflush(1);
STDOUT->autoflush(1);

our $opt_v = 0;
our $opt_c = $ENV{'HOME'}."/.hcli.conf";
our $opt_p;

our $opt_C; # market_search
our $opt_D; # market_search
our $opt_M; # market_search


getopts('c:p:vC:D:M:');

my $conf = $opt_c;
my $config = { };

if (! -f $conf) {
	die("config file '$conf' does not exist");
}
if (!open(C,$conf)) {
	die("could not open $conf");
}
my $line;
while(<C>) {
	if (/^\s*$/ || /^\s*#/) {
		next;
	}
	chomp($line=$_);
	if ($line =~ /^\s*(\S+)\s*=\s*(.*)\s*$/) {
		my ($var,$val) = ($1, $2);
		#printf "loadconf found '%s' = '%s'\n", $var, $val;

		$config->{$var}=$val;
		next;
	}
	printf "Unhandled config line: %s\n", $line;
}
close(C);

my $hetzner = WWW::Hetzner->new(
	huser => $config->{huser},
	hpass => $config->{hpass},
);

if ($opt_p eq "ip") {

	my $call = "ip";
	my $parsed = $hetzner->req($call);
	print recurse_dump($parsed);
	exit(0);
}

if($opt_p eq "servers") {
	my @servers = $hetzner->servers;
	foreach my $srvr (@servers) {
		my $ip = $srvr->ip;
		my @sub = @{$srvr->get('subnet')};
		printf "%d %12s: %s\n",
			$srvr->get('server_number'),
			$srvr->get('server_name'),
			$srvr->get('paid_until'),
		;
		my $server_ip = $srvr->get('server_ip');
		my $server_gw = $srvr->get('ip')->get('gateway');
		if (!defined($server_gw)) {
			$server_gw = "<undef>";
		}
		printf "\t%15s gw %15s\n",
			$server_ip,
			$server_gw,
		;
		printf "\t%s/%s\n",
			$sub[0]->{ip},
			$sub[0]->{mask},
		;
		my ($i,$o,$s) = $srvr->traffic;
		if (defined($i) && defined($o) && defined($s)) {
			printf "\ttraffic in/out/sum = %f/%f/%f\n", $i, $o, $s;
		}
		my $ptr = $srvr->rdns;
		if (defined($ptr)) {
			printf "\trdns %s ptr %s\n", $server_ip, $ptr;
		}
		my $cancel = $srvr->cancel;
		if (defined($cancel)) {
			printf "\tcancel earliest %s, status %s, ",
				$cancel->get('earliest_cancellation_date'),
				$cancel->get('cancelled'),
			;
			my $cdate = $cancel->get('cancellation_date');
			if ($cdate ne "<undef>") {
				printf "date %s, ", $cdate;
			}
			my $reason = $cancel->get('cancellation_reason');
			if (ref($reason) eq "ARRAY") {
				print "reasons [";
				foreach my $r (@{$reason}) {
					printf "'%s',", $r;
				}
				print "]\n";
			}
		}
		#my $fire = $srvr->firewall;
		#print recurse_dump($fire);
	}
	#print recurse_dump($parsed);
	exit(0);
}

if($opt_p eq "reset") {
	my $call = "reset";
	my $parsed = $hetzner->req($call);
	foreach my $r (@{$parsed}) {
		my $types;
		foreach my $t (@{$r->{reset}->{type}}) {
			if (!defined($types)) {
				$types = $t;
				next;
			}
			$types .= ",".$t;
		}
		printf "%7d %16s %s\n",
			$r->{reset}->{server_number},
			$r->{reset}->{server_ip},
			$types;
	}
	#print recurse_dump($parsed);
	exit(0);
}

if($opt_p eq "subnet") {
	my $call = "subnet";
	my $parsed = $hetzner->req($call);
	print recurse_dump($parsed);
	exit(0);
}

if($opt_p eq "rdns") {
	my $call = "rdns";
	my $parsed = $hetzner->req($call);
	print recurse_dump($parsed);
	exit(0);
}

if($opt_p eq "sshkey") {
	my $call = "key";
	my $parsed = $hetzner->req($call);
	print recurse_dump($parsed);
	exit(0);
}

if($opt_p eq "products") {
	my $call = "order/server/product";
	my $parsed = $hetzner->req($call);
	print recurse_dump($parsed);
	exit(0);
}

if($opt_p eq "storagebox") {
	my $call = "storagebox";
	my $parsed = $hetzner->req($call);
	print recurse_dump($parsed);
	exit(0);
}

if($opt_p eq "server_transactions") {
	my $call = "order/server/transaction";
	my $parsed = $hetzner->req($call);
	print recurse_dump($parsed);
	exit(0);
}

if($opt_p eq "market_transactions") {
	my $call = "order/server_market/transaction";
	my $parsed = $hetzner->req($call);
	print recurse_dump($parsed);
	exit(0);
}

if($opt_p eq "traffic") {
	my $call = "traffic";
	my $type="month";
	my $from=uri_escape_utf8("2017-01-01");
	my $to=uri_escape_utf8("2017-12-31");
	$call .= "?type=$type";
	$call .= "&from=$from";
	$call .= "&to=$to";
	my $parsed = $hetzner->req($call);
	print recurse_dump($parsed);
	exit(0);
}

if($opt_p eq "market_search") {

	# move defaults to WWW::Hetzner::MarketSearch once created
	if (!defined($opt_C)) {
		$opt_C = 5682;
	}
	if (!defined($opt_D)) {
		$opt_D = 4096;
	}
	if (!defined($opt_M)) {
		$opt_M = 48;
	}

	my $call = "order/server_market/product?search=Ent";

	if (defined($opt_C)) {
		$call .= "&min_cpu_benchmark=${opt_C}"
	}
	if (defined($opt_M)) {
		$call .= "&min_memory_size=${opt_M}"
	}

	print "OUTPUT:\n";


	my $parsed = $hetzner->req($call);
	#print recurse_dump($parsed);
	#print "\n\n";

	printf "%8s %7s %5s %5s %5s %3s %6s %6s %3s %6s\n",
		"DC","prodid","sys","bench","disk","MEM","EUR","next","TB","CPU info";
	foreach my $server ( @{$parsed} ) {

		my $dc   = $server->{product}->{datacenter};
		my $mem  = $server->{product}->{memory_size};
		my $cpub = $server->{product}->{cpu_benchmark};
		my $disk = $server->{product}->{hdd_count} * $server->{product}->{hdd_size};

		if ($cpub < $opt_C) {
			next;
		}
		if ($mem < $opt_M) {
			next;
		}
		if ($disk < $opt_D) {
			next;
		}
		my $traffic = $server->{product}->{traffic};
		$traffic =~ s/ TB$//;
		$dc =~ s/-DC/-/;
	
		printf "%8s %7d %5s %5d %5d %3d %6.2f %6d %3s %s\n",
			$dc,
			$server->{product}->{id},
			$server->{product}->{name},
			$cpub,
			$disk,
			$server->{product}->{memory_size},
			$server->{product}->{price},
			$server->{product}->{next_reduce},
			$traffic,
			$server->{product}->{cpu},
	}
	exit(0);
}

my $p = $opt_p;
if (!defined($p)) {
	$p = "<undef>";
}
printf "personality '%s' not found\n", $p;
exit(1);

sub recurse_dump {
	my ($item) = @_;
	my $d = Data::Dumper->new([$item]);
	$d->Purity(1);
	$d->Terse(0);
	$d->Deepcopy(1);
	$d->Indent(2);
	$d->Sortkeys(1);
	#$d->Deparse(1);
	return $d->Dump();
}
